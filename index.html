<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>net2</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="moteur-physique-verlet">Moteur physique Verlet</h1>
<h2 id="intégration-deuler">Intégration d’Euler</h2>
<p>La majorité des moteurs de jeux qui offrent de l’interaction physique entre objets font appel à l’intégration d’Euler qui est une méthode numérique de résolution d’équations différentielles du premier ordre.</p>
<p>L’implémentation rudimentaire consiste à, pour chaque objet, attribuer une position, vitesse et accélération, et à chaque itération de la simulation, ajouter la vitesse à la position et l’accélération à la vitesse.</p>
<pre><code>update():
    position += velocity * dt
    velocity += acceleration * dt    
</code></pre>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ee/Forward_Euler_method_illustration.png/220px-Forward_Euler_method_illustration.png" alt="euler_integration"></p>
<p>Cette méthode est relativement simple à implémenter et offre de bonne performances, cependant celle-ci a tendance à être instable. La cause étant qu’avec la simulation numérique, il est impossible d’avoir de la simulation continue, nous sommes donc contraint de faire avancer la simulation d’un pas de temps donné <strong>dt</strong> (dans le cas d’une simulation à 60Hz, 1/60 ms, soit 0.017ms), ce qui introduit de l’imprécision dans les calculs de trajectoire.</p>
<p>C’est pourquoi nous allons explorer l’implémentation d’un moteur physique faisant appel à l’intégration de Verlet.</p>
<h2 id="intégration-de-verlet">Intégration de Verlet</h2>
<p>L’intégration de Verlet consiste à déduire la vélocité à partir de la position actuelle et de la position précédente.</p>
<pre><code>update()
    tmp = pos
    pos = 2*pos - old_pos + acceleration * dt²
    old_pos = tmp
</code></pre>
<p>La vélocité n’étant pas stockée en dur, le système devient de facto plus stable.</p>
<p>Pour rendre les choses moins glissante, il suffit d’ajouter un facteur de friction lors de la mise à jour de la position.</p>
<h2 id="implémentation">Implémentation</h2>
<h3 id="particle-system">Particle system</h3>
<p>Les moteurs de simulation physiques utilisent un système de particules.<br>
L’utilisation de la méthode de Verlet rend cette implémentation relativement simple.</p>
<p>Voici un premier rendu avec le traçage d’une unique particule auquel on a appliqué de la gravité et une “vélocité” initiale. À noter que pour empêcher la particule de sortir de la zone, une simple contrainte [min, max] sur ses coordonnées suffit.<br>
<img src="https://raw.githubusercontent.com/Fikzy/NET2/master/simple_particle.png" alt="simple_particle" width="400" height="400"></p>
<p>Là où les choses deviennent intéressante, c’est lors de l’ajout de contraintes entre les particules.</p>
<h3 id="stick-constraint">Stick constraint</h3>
<p>La contrainte la plus basique est la “stick constraint” ou contrainte bâton. Elle va nous permettre de construire tout type de formes géométriques.<br>
Celle-ci consiste à enforcer la conservation d’une distance initiale entre deux particules.</p>
<p><img src="https://raw.githubusercontent.com/Fikzy/NET2/589b7d49e166840acaa2c13276db705a461490d3/stick_constraint.svg" alt="stick_constraint"></p>
<p>Pour satisfaire cette contrainte, il suffit alors d’ajouter le décalage nécessaire afin de rapprocher ou d’éloigner les deux particules.</p>
<pre><code>delta = p2 - p1
delta_length = sqrt(dot(delta, delta))
ratio = (delta_length - init_length) / init_length
p1 -= delta * ratio / 2
p2 += delta * ratio / 2
</code></pre>
<p>Voici un rendu d’une simple contrainte entre deux particules : un joli bâton !<br>
<img src="https://raw.githubusercontent.com/Fikzy/NET2/master/stick_constraint.gif" alt="enter image description here" width="400" height="400"></p>
<p>L’avantage de cette approche que l’on constate immédiatement est qu’aucun traitement particulier n’est nécessaire pour la rotation d’objets !</p>
<p>Comme dit précédemment, avec ce type de contrainte, nous sommes en mesure de créer des formes géométriques.<br>
<img src="https://raw.githubusercontent.com/Fikzy/NET2/master/squishy_triangle.gif" alt="enter image description here" width="400" height="400"></p>
<p>Cependant ici quelque chose ne va pas. La pièce ne semble pas rigide.</p>
<p>Le soucis est que les contraintes ne sont pas résolues assez rapidement, ce qui donne cette impression de “mou”. Pour contrer le problème, il suffit alors de résoudre les contraintes plusieurs fois par itération. Cela a évidemment un coût, mais en général un petit nombre d’itérations suffit amplement.</p>
<p>Voici le même triangle, avec 3 itérations pour la résolution de contraintes :<br>
<img src="https://raw.githubusercontent.com/Fikzy/NET2/master/triangle.gif" alt="enter image description here" width="400" height="400"></p>
<p>Voici un cas plus complexe parfaitement supporté : une chaîne !<br>
<img src="https://raw.githubusercontent.com/Fikzy/NET2/master/chain.gif" alt="enter image description here" width="400" height="400"></p>
</div>
</body>

</html>
